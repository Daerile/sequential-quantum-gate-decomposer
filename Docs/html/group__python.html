<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sequential Quantum Gate Decomposer: Python Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Sequential Quantum Gate Decomposer"/>
<link href="QGD_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sequential Quantum Gate Decomposer
   &#160;<span id="projectnumber">v1.6</span>
   </div>
   <div id="projectbrief">Powerful decomposition of general unitarias into one- and two-qubit gates gates</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,true,'search.php','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Python Interface</div>  </div>
</div><!--header-->
<div class="contents">
<h1>Introduction</h1>
<p>Sequential Quantum <a class="el" href="class_gate.html" title="Base class for the representation of general gate operations. ">Gate</a> Decomposer (SQUANDER) package provides an interface to Python which makes it possible to combine SQUANDER with well known quantum computing back ends, like <a href="https://qiskit.org/">Qiskit</a>. In fact, SQUANDER has already established an interface to export the decomposed quantum circuit in Qiskit format. The Python interface of SQUANDER is developed <a href="https://docs.python.org/3/library/ctypes.html">C++ extensions</a>, while all the massive calculations related to the decomposition run in C++, and only the input and final output parameters are casted between C++ and Python types.</p>
<p>In the forthcoming sections we provide some tricks and best practices to use the SQUANDER Python interface. The SQUANDER Python interface can be tested by running the test cases by pytest utility or by example scripts in the examples directory of the source directory of the SQUANDER package: (To build the SQUANDER package follow the manual at <a href="index.html">Main Page</a>.)</p>
<div class="snippet"> $ cd path/to/qgd &amp;&amp; pytest </div><p>or</p>
<div class="snippet"> $ cd path/to/qgd/examples &amp;&amp; python3 <a class="el" href="example_8py.html" title="Simple example python code demonstrating the basic usage of the Python interface of the Quantum Gate ...">example.py</a> </div><p>The script <a class="el" href="example_8py.html" title="Simple example python code demonstrating the basic usage of the Python interface of the Quantum Gate ...">example.py</a> solves two problems:</p><ul>
<li>the decomposition of a general three-qubit unitary</li>
<li>the decomposition of the <a href="https://www.ibm.com/blogs/research/2020/05/quantum-challenge-results/">4th IBM Challenge problem</a></li>
</ul>
<p>The expected outcome of the test script should look as:</p>
  <style>div.image img[src="example_result.png"]{width:1200px;}</style>  </p><div class="image">
<img src="example_result.png" alt="example_result.png"/>
<div class="caption">
Expected result for the 4th IBM Challenge problem</div></div>
<p> The output informs us that the 4th IBM Challenge problem was solved by using 4 <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates with decomposition error <img class="formulaInl" alt="$4.31\times10^{-8}$" src="form_6.png"/>. It is evident that the given decomposition can be further simplified by the union of successive <a class="el" href="class_u3.html" title="A class representing a U3 gate. ">U3</a> operations, however the SQUANDER package is not equipped yet to do such simplifications. (The decomposition result of the general three-qubit matrix can be found above the result of the IBM challenge on the standard output.)</p>
<h1>Writing your own scripts</h1>
<p>In this example we show how to use the python interface of the SQUANDER package for our own purposes. To this end we demonstrate the steps provided in the examples <a class="el" href="test___q_x2_8py.html">test_QX2.py</a> and <a class="el" href="example_8py.html" title="Simple example python code demonstrating the basic usage of the Python interface of the Quantum Gate ...">example.py</a> to decompose a 4-qubit unitary onto the <b><a href="https://github.com/Qiskit/ibmq-device-information/tree/master/backends/yorktown/V1">QX2</a></b> architecture of IBM, and to solve the 4th problem of the IBM Challenge 2020, respectively.</p>
<h2>Decomposing general unitary for QX2 architecture</h2>
<p>The ability to decompose a quantum program into gate structures with sparse connectivity is undoubtedly an important issue of quantum programming. One theoretically possible way to overcome this issue is to apply swap gates to get distant qubits close to each other where the desire two-qubit controlled operation can be applied on them, and then move the qubits back to their initial position by another swap operations. Here we report on a novel approach to optimize a quantum circuit of general unitaries. The key point of our approach is to find the best decomposition of a quantum program from the start, without implementing additional swap gates into the decomposed circuit.</p>
<p>The <a href="https://github.com/Qiskit/ibmq-device-information/tree/master/backends/yorktown/V1">QX2</a> architecture consists of 5 qubits. In order to decompose a 4-qubit unitary on this system we need to select four qubits from the five.</p>
  <style>div.image img[src="QX2_intel.png"]{width:300px;}</style>  </p><div class="image">
<img src="QX2_intel.png" alt="QX2_intel.png"/>
<div class="caption">
5-qubit quantum computer achitecture</div></div>
<p>The choice of the four qubits might be in principle arbitrary, as long as the chosen set contains the central q2 qubit. In our example we decompose a general 4-qubit unitary on qubits q0, q1, q2 and q3 of the QX2. At the beginning of the decomposition we need to decide the order in which we are going to disentangle the qubits from the others. In general, qubits having the most connections are the easiest to disentangle from the others. However, since qubit q2 plays a central role in the design, we need to choose another qubit to begin with, otherwise there would be left no direct connection to qubit q3 and it would be not possible to finish the decomposition without using swap gates. For example, we might choose qubit q0 as the first one to disentangle. (We notice that at this point qubit Q1 would be equivalently good choice.) Then we can continue the decomposition with getting qubit q1 independent from the others, and finally we disentangle the remaining two qubits q2 and q3.</p>
<p>Now we proceed by the description of the specific programming steps of the above described desomposition strategy. The SQUANDER Python interface is installed into the Python module <b><a class="el" href="namespaceqgd__python.html">qgd_python</a></b> located in the installation path of the SQUANDER package. In order to start using the SQUANDER Python interface, one need to import the python binding for the <a class="el" href="class_n___qubit___decomposition.html" title="A base class to determine the decomposition of an N-qubit unitary into a sequence of CNOT and U3 gate...">N_Qubit_Decomposition</a> class:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="keyword">from</span> <a class="code" href="namespaceqgd__python_1_1decomposition_1_1qgd___n___qubit___decomposition.html">qgd_python.decomposition.qgd_N_Qubit_Decomposition</a> <span class="keyword">import</span> qgd_N_Qubit_Decomposition </div></div><!-- fragment --></div><p>In general, to import the SQUANDER Python module the Python interpreter should see it on the module search path (for further details see the <a href="https://docs.python.org/3/tutorial/modules.html">module tutorial</a>). In the next step we define the number of the qubits for which a random unitary is constructed.</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># the number of qubits spanning the unitary</span></div><div class="line">qbit_num = 4</div></div><!-- fragment --></div><p>Now we create a random unitary to be decomposed:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># determine the soze of the unitary to be decomposed</span></div><div class="line">matrix_size = int(2**qbit_num)</div><div class="line">   </div><div class="line"><span class="comment"># creating a random unitary to be decomposed</span></div><div class="line">Umtx = unitary_group.rvs(matrix_size)</div></div><!-- fragment --></div><p>After successful import of the <a class="el" href="namespaceqgd__python_1_1decomposition_1_1qgd___n___qubit___decomposition.html">qgd_python.decomposition.qgd_N_Qubit_Decomposition</a> class we create an instance of class used to bring the given unitary into identity by a sequence of two-qubit and one-qubit gates:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># creating an instance of the C++ class</span></div><div class="line">decomp = qgd_N_Qubit_Decomposition( Umtx.conj().T )</div></div><!-- fragment --></div><p>Notice, that we gave the complex transpose of the unitary Umtx as an input for the class <a class="el" href="namespaceqgd__python_1_1decomposition_1_1qgd___n___qubit___decomposition.html">qgd_python.decomposition.qgd_N_Qubit_Decomposition</a>. This can be explained by simple linear algebra considerations: since the product of the unitary with it's complex transpose ( <img class="formulaInl" alt="$U U^\dagger=I$" src="form_2.png"/>) gives identity, the sequence of operations bringing a unitary <img class="formulaInl" alt="$U$" src="form_3.png"/> into identity would naturally equal to the complex transpose <img class="formulaInl" alt="$U^\dagger$" src="form_4.png"/> of the unitary <img class="formulaInl" alt="$U$" src="form_3.png"/>.</p>
<p>Since the SQUANDER package process the decomposition of general unitaries in specific order of the qubits (always disentangling the qubit with the highest index), we need to re-label the qubits, so SQUANDER can disentangle the qubits in the correct order by instructions:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># list of reordered qubits (original: (3,2,1,0) )</span></div><div class="line">reordered_qbits = (0,1,3,2)</div><div class="line"></div><div class="line"><span class="comment"># adding custom gate structure to the decomposition</span></div><div class="line">decomp.Reorder_Qubits( reordered_qbits )</div></div><!-- fragment --></div>  <style>div.image img[src="QX2.png"]{width:600px;}</style>  </p><div class="image">
<img src="QX2.png" alt="QX2.png"/>
<div class="caption">
Decomposing gate structure for the QX2 architecture.</div></div>
<p> The relabeled qubits are indicated by the red numbers in the figure above showing the "Decomposing gate structure for the QX2 architecture". After relabeling the qubits, we set the custom gate structure by:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># create custom gate structure</span></div><div class="line">gate_structure = { 4: <a class="code" href="namespaceexample___q_x2.html#aa388edf6e3ad3df05a84d6620bc0fcc6">create_custom_gate_structure_QX2</a>(4), 3: <a class="code" href="namespaceexample___q_x2.html#aa388edf6e3ad3df05a84d6620bc0fcc6">create_custom_gate_structure_QX2</a>(3)}        </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># adding custom gate structure to the decomposition</span></div><div class="line">decomp.set_Gate_Structure( gate_structure )</div></div><!-- fragment --></div><p>The python dict <b>gate_structures</b> contains a period of decomposing gate structures to disentangle the 4-th and the 3-rd qubit. These gate structure segments are created with an individual function <b>create_custom_gate_structure_QX2</b> described in forthcoming paragraphs.</p>
<p>After setting the design of the decomposing gate structure, we can override the default number of decomposing layers (i.e. the number describing haw many times a period is repeated in the gate structure) for the decomposition:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># set the maximal number of layers in the decomposition</span></div><div class="line">decomp.set_Max_Layer_Num( {4: 60, 3:16} )</div></div><!-- fragment --></div><p>In this example we set 60 layers to disentangel the 4-th qubit (i.e. q3) and 16 layers to disentangle the 3-rd qubit (i.e. q2) from the rest.</p>
<p>Finally we start the decomposition by</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># starting the decomposition</span></div><div class="line">decomp.Start_Decomposition()</div></div><!-- fragment --></div><p>After the decompsoition is done, we revert the labeling of the qubits to the initial state corresponding to the QX2 architecture:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># list of reordered qubits to revert the initial order</span></div><div class="line">revert_qbits = (1,0,2,3)             </div><div class="line"></div><div class="line"><span class="comment"># adding custom gate structure to the decomposition</span></div><div class="line">decomp.Reorder_Qubits( revert_qbits )</div></div><!-- fragment --></div><p>Using these instructions we revert the labels of the qubits indicated by red numbers to the initial black colored labels. (See figure above showing the "Decomposing gate structure for the QX2 architecture".)</p>
<p>Finally, we show the way to define custom gate structures for the decomposition. First we import and create a class that will hold the design of one period of the decomposing gate structure. (This period of gates is then repeated in the quantum circuit.)</p>
<div class="snippet"> <div class="fragment"><div class="line">    <span class="keyword">from</span> qgd_python.gates.qgd_Gates_Block <span class="keyword">import</span> qgd_Gates_Block</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># creating an instance of the wrapper class qgd_Gates_Block</span></div><div class="line">    Gates_Block_ret = <a class="code" href="structqgd___gates___block.html">qgd_Gates_Block</a>( qbit_num )</div></div><!-- fragment --></div><p>Then we can initialize the label of the qubit we need to disentangle. (SQUANDER always disentagles the qubit with the highes label.) </p><div class="snippet"> <div class="fragment"><div class="line">    disentangle_qbit = qbit_num - 1 </div></div><!-- fragment --></div><p>The custom gate structure can be constructed by the creation of a layers and appending gates into it. The layer is defined again by an instance of class qgd_Gates_block:</p>
<div class="snippet"> <div class="fragment"><div class="line">        <span class="comment"># creating an instance of the wrapper class qgd_Gates_Block</span></div><div class="line">        Layer = <a class="code" href="structqgd___gates___block.html">qgd_Gates_Block</a>( qbit_num )</div></div><!-- fragment --></div><p>In the created layer we can choose between the qubits to play the role of the control and the target qubit on demand. Whatever is our choice, we should apply <a class="el" href="class_u3.html" title="A class representing a U3 gate. ">U3</a> gates to the qubits in front of the two-qubit controlled gate.</p>
<div class="snippet"> <div class="fragment"><div class="line">            <span class="comment"># add U3 gate to the block</span></div><div class="line">            Theta = <span class="keyword">True</span></div><div class="line">            Phi = <span class="keyword">False</span></div><div class="line">            Lambda = <span class="keyword">True</span>      </div><div class="line">            Layer.add_U3( 0, Theta, Phi, Lambda )                 </div><div class="line">            Layer.add_U3( 1, Theta, Phi, Lambda ) </div><div class="line"></div><div class="line">            <span class="comment"># add CNOT gate to the block</span></div><div class="line">            Layer.add_CNOT( 0, 1)</div><div class="line"></div></div><!-- fragment --></div><p>The <a class="el" href="class_u3.html" title="A class representing a U3 gate. ">U3</a> gates should have two free parameters, lets say variable Theta and Lambda, while parameter Phi is kept constant zero during the decompsition. (Parameters set to True are free parameters, while parameters set to False are kept constant.) In the code snippet above a connection between qubits 0 and 1 is created via a <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gate. In particular, qubit 1 is chosen as the target qubit, and qubit 0 is chosen to be the target qubit. Finally, the created layer should be added to the class instance holding the gate design to be used in the decomposiotion</p>
<div class="snippet"> <div class="fragment"><div class="line">        Gates_Block_ret.add_Gates_Block( Layer )</div></div><!-- fragment --></div><p>Here we constructed only a single layer, other layers can be constructed following the same logic. The whole, functioning code of the example can be found in example file example_QX2.py.</p>
<h2>Solution of the 4th problem of the IBM Challenge 2020</h2>
<p>Now we turn our attention to solve the 4th problem of the IBM Challenge 2020. Here we demonstrate that advanced tuning of parameters can help to decompose special unitaries into quantum circuits wirh few <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates. We show haw the SQUANDER package can be used to decompose the unitary of the 4th problem of the IBM Challenge 2020 using 4 <a class="el" href="class_c_z.html" title="A class representing a CZ operation. ">CZ</a> gates.</p>
<p>After importing the <a class="el" href="namespaceqgd__python_1_1decomposition_1_1qgd___n___qubit___decomposition__adaptive.html">qgd_python.decomposition.qgd_N_Qubit_Decomposition_adaptive</a> class by command, </p><div class="snippet"> <div class="fragment"><div class="line"><span class="keyword">from</span> <a class="code" href="namespaceqgd__python_1_1decomposition_1_1qgd___n___qubit___decomposition__adaptive.html">qgd_python.decomposition.qgd_N_Qubit_Decomposition_adaptive</a> <span class="keyword">import</span> qgd_N_Qubit_Decomposition_adaptive       </div></div><!-- fragment --></div><p>we need to load the 4-qubit matrix of the problem from a file shipped with the SQUANDER package:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</div><div class="line">    </div><div class="line"></div><div class="line">data = loadmat(<span class="stringliteral">&#39;Umtx.mat&#39;</span>)  </div><div class="line"></div><div class="line">Umtx = data[<span class="stringliteral">&#39;Umtx&#39;</span>]</div></div><!-- fragment --></div><p>Then we create the class to be used for the decomposition, which synthesize the given unitary in terms of of <a class="el" href="class_c_z.html" title="A class representing a CZ operation. ">CZ</a>, <a class="el" href="class_u3.html" title="A class representing a U3 gate. ">U3</a> and <a class="el" href="class_r_x.html" title="A class representing a U3 gate. ">RX</a> operations:</p>
<div class="snippet"> <div class="fragment"><div class="line"></div><div class="line">cDecompose = qgd_N_Qubit_Decomposition_adaptive( Umtx.conj().T, level_limit_max=5, level_limit_min=0 )</div></div><!-- fragment --></div><p>Notice, that we gave the complex transpose of the unitary Umtx as an input for the class <a class="el" href="namespaceqgd__python_1_1decomposition_1_1qgd___n___qubit___decomposition__adaptive.html">qgd_python.decomposition.qgd_N_Qubit_Decomposition_adaptive</a>. This can be explained by simple linear algebra considerations: since the product of the unitary with it's complex transpose ( <img class="formulaInl" alt="$U U^\dagger=I$" src="form_2.png"/>) gives identity, the sequence of operations bringing a unitary <img class="formulaInl" alt="$U$" src="form_3.png"/> into identity would naturally equal to the complex transpose <img class="formulaInl" alt="$U^\dagger$" src="form_4.png"/> of the unitary <img class="formulaInl" alt="$U$" src="form_3.png"/>.</p>
<p>Along with the input unitary we provided two other inputs for the decomposition class.</p><ul>
<li><b>level_limit_max</b> The maximal number of decomposing unit cells used in the synthesis</li>
<li><b>level_limit_min</b> The minimal number of decomposing unit cells used in the synthesis.</li>
</ul>
<p>Finally, we set the verbosity to the highest level:</p>
<div class="snippet"> <div class="fragment"><div class="line"></div><div class="line"><span class="comment"># setting the verbosity of the decomposition</span></div><div class="line">cDecompose.set_Verbose( 3 )</div><div class="line"></div></div><!-- fragment --></div><p>and start the decomposition by the command:</p>
<div class="snippet"> <div class="fragment"><div class="line"><span class="comment"># starting the decomposition</span></div><div class="line">cDecompose.Start_Decomposition()</div><div class="line"></div><div class="line"><span class="comment"># list the decomposing operations</span></div><div class="line">cDecompose.List_Gates()</div></div><!-- fragment --></div><p>The second command in the above code snippet prints the list of decomposing operations on the standard output. Finally, we can export a Qiskit compatible quantum circuit via the SQUANDER Python interface and calculate the final error of the decomposition by the following code snippet:</p>
<div class="snippet"> <div class="fragment"><div class="line">print(<span class="stringliteral">&#39; &#39;</span>)</div><div class="line">print(<span class="stringliteral">&#39;Constructing quantum circuit:&#39;</span>)</div><div class="line">print(<span class="stringliteral">&#39; &#39;</span>)</div><div class="line"></div><div class="line">quantum_circuit = cDecompose.get_Quantum_Circuit()</div><div class="line"></div><div class="line">print(quantum_circuit)</div><div class="line"></div><div class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> execute</div><div class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> Aer</div><div class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> LA</div><div class="line">    </div><div class="line"><span class="comment"># test the decomposition of the matrix</span></div><div class="line"></div><div class="line">backend = Aer.get_backend(<span class="stringliteral">&#39;unitary_simulator&#39;</span>)</div><div class="line">    </div><div class="line"></div><div class="line">job = execute(quantum_circuit, backend)</div><div class="line"></div><div class="line">result = job.result()</div><div class="line">    </div><div class="line"></div><div class="line">decomposed_matrix = np.asarray( result.get_unitary(quantum_circuit) )</div><div class="line">product_matrix = np.dot(Umtx,decomposed_matrix.conj().T)</div><div class="line">phase = np.angle(product_matrix[0,0])</div><div class="line">product_matrix = product_matrix*np.exp(-1j*phase)</div><div class="line">    </div><div class="line">product_matrix = np.eye(matrix_size)*2 - product_matrix - product_matrix.conj().T</div><div class="line"><span class="comment"># the error of the decomposition</span></div><div class="line">decomposition_error =  (np.real(np.trace(product_matrix)))/2</div><div class="line">       </div><div class="line">print(<span class="stringliteral">&#39;The error of the decomposition is &#39;</span> + str(decomposition_error))</div><div class="line"></div></div><!-- fragment --></div><p>The documentation of Qiskit, which is needed to fully understand the above code snippet, can be found <a href="https://qiskit.org/documentation/">here</a>. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 20 2022 10:31:20 for Sequential Quantum Gate Decomposer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
