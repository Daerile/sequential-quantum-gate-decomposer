<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Quantum Gate Decomposer: Python Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Quantum Gate Decomposer"/>
<link href="QGD_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quantum Gate Decomposer
   &#160;<span id="projectnumber">v1.1</span>
   </div>
   <div id="projectbrief">Powerful decomposition of almost any unitary into U3 and CNOT gates</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="group__examples.html"><span>Examples</span></a></li>
      <li><a href="group__python.html"><span>Python&#160;Interface</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="group__faq.html"><span>FAQ</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Python Interface</div>  </div>
</div><!--header-->
<div class="contents">
<h1>Introduction</h1>
<p>The Quantum Gate Decomposer (QGD) package provides a very simple interface to Python which makes it possible to combine QGD with well known quantum computing back ends, like <a href="https://qiskit.org/">Qiskit</a>. In fact, QGD has already established an interface to export the decomposed quantum circuit in Qiskit format. The Python interface of QGD is developed using <a href="https://docs.python.org/3/library/ctypes.html">Ctypes</a>, while all the massive calculations related to the decomposition run in native C, and only the input and final output parameters are casted between C and Python types.</p>
<p>In the forthcoming sections we provide some tricks and best practices to use the QGD Python interface. The QGD Python interface can be tested by running the <b><a class="el" href="example_8py.html" title="Simple example python code demonstrating the basic usage of the Python interface of the Quantum Gate ...">example.py</a></b> script right in the installation directory of the QGD package. (To install the QGD package follow the manual at <a href="index.html">Main Page</a>).</p>
<div class="snippet"> $ cd path/to/qgd &amp;&amp; python3 <a class="el" href="example_8py.html" title="Simple example python code demonstrating the basic usage of the Python interface of the Quantum Gate ...">example.py</a> </div><p>The example solves two problems:</p><ul>
<li>the decomposition of a general three-qubit unitary</li>
<li>the decomposition of the <a href="https://www.ibm.com/blogs/research/2020/05/quantum-challenge-results/">4th IBM Challenge problem</a></li>
</ul>
<p>The expected outcome of the test script should look as:</p>
  <style>div.image img[src="example_result.png"]{width:1200px;}</style>  </p><div class="image">
<img src="example_result.png" alt="example_result.png"/>
<div class="caption">
Expected result for the 4th IBM Challenge problem</div></div>
<p> The output informs us that the 4th IBM Challenge problem was solved by using 4 <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates with decomposition error 0.00010325.... It evident that the given decomposition can be further simplified by the union of successive <a class="el" href="class_u3.html" title="A class representing a U3 operation. ">U3</a> operations, however the QGD package is not equipped yet to do such simplifications. (The decomposition result of the general three-qubit matrix can be found somewhere above the result of the IBM challenge in the standard output.)</p>
<h1>Writing our own scripts</h1>
<p>In this example we show how to use the python interface of the Quantum Gate Decomposer package for our own purposes. To this end we demonstrate the steps in the <a class="el" href="example_8py.html" title="Simple example python code demonstrating the basic usage of the Python interface of the Quantum Gate ...">example.py</a> to solve the 4th problem of the IBM Challenge 2020. The QGD Python interface is installed into the Python module <b><a class="el" href="namespaceqgd__python.html">qgd_python</a></b> located in the installation path of the QGD package. In order to start using the QGD Python interface, one need to import the <a class="el" href="class_n___qubit___decomposition.html" title="A class to determine the decomposition of a unitary into a sequence of CNOT and U3 operations...">N_Qubit_Decomposition</a> class from this module:</p>
<div class="snippet"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> <a class="code" href="namespaceqgd__python_1_1_n___qubit___decomposition.html">qgd_python.N_Qubit_Decomposition</a> <span class="keyword">import</span> N_Qubit_Decomposition </div></div><!-- fragment --></div><p>In general, to import the QGD Python module, the Python interpreter should see it on the module search path (for further details see the <a href="https://docs.python.org/3/tutorial/modules.html">module tutorial</a>). After loading the <a class="el" href="namespaceqgd__python.html">qgd_python</a> module we need to load the 4-qubit matrix of the problem from a file shipped with the QGD package:</p>
<div class="snippet"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    </div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">## load the unitary from file</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;data = loadmat(<span class="stringliteral">&#39;Umtx.mat&#39;</span>)  </div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">## The unitary to be decomposed  </span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Umtx = data[<span class="stringliteral">&#39;Umtx&#39;</span>]</div></div><!-- fragment --></div><p>Then we create the class to be used for the decomposition, which tries to bring the given unitary into identity by a sequence of <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> ans <a class="el" href="class_u3.html" title="A class representing a U3 operation. ">U3</a> operations:</p>
<div class="snippet"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">## creating a class to decompose the unitary</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cDecompose = <a class="code" href="classqgd__python_1_1_n___qubit___decomposition_1_1_n___qubit___decomposition.html">N_Qubit_Decomposition</a>( Umtx.conj().T, optimize_layer_num=<span class="keyword">True</span>, initial_guess=<span class="stringliteral">&quot;zeros&quot;</span> )</div></div><!-- fragment --></div><p>Notice, that we gave the complex transpose of the unitary Umtx as an input for the class <a class="el" href="class_n___qubit___decomposition.html" title="A class to determine the decomposition of a unitary into a sequence of CNOT and U3 operations...">N_Qubit_Decomposition</a>. This can be explained by simple linear algebra considerations: since the product of the unitary with it's complex transpose ( <img class="formulaInl" alt="$U U^\dagger=I$" src="form_2.png"/>) gives identity, the sequence of operations bringing a unitary <img class="formulaInl" alt="$U$" src="form_3.png"/> into identity would naturally equal to the complex transpose <img class="formulaInl" alt="$U^\dagger$" src="form_4.png"/> of the unitary <img class="formulaInl" alt="$U$" src="form_3.png"/>.</p>
<p>Along with the input unitary we provided two other inputs for the decomposition class.</p><ul>
<li><b>optimize_layer_num</b> Set true to try to find the fewest number of <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates necessary for the decomposition (increasing the running time) or false when the predefined maximal number of layer gates is used for the decomposition (which fit better for general unitaries).</li>
<li><b>initial_guess</b> String indicating the method to guess initial values for the optimization. Possible values:<ul>
<li>"zeros": the initial guessed values are all zeros,</li>
<li>"random": the initial guessed values are random doubles,</li>
<li>"close_to_zero": the initial guessed values are random numbers close to zero.</li>
</ul>
</li>
</ul>
<p>In case we would like to minimize the number of <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates in the decomposition, the best choice for the <b>initial_guess</b> values are **"zeros"** (discussed in more details in the forthcoming sections). However, this kind of the choice might result unwanted convergence of the optimization to local minimum instead of the global one. Thus, the solution of this example might sometimes fail to reach the global minimum. For the same reason, unitaries consisting of much <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates can be well decomposed by initial guess values **"random"** or **"close_to_zero"**.</p>
<p>Finally, before we start the decomposition, we set some other parameters for the decomposition.</p>
<div class="snippet"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># set the number of successive identical blocks in the optimalization of disentanglement of the n-th qubits</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cDecompose.set_identical_blocks( {4: 2, 3: 1} )</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"># set the maximal number of layers in the decomposition</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;cDecompose.set_max_layer_num( {4: 9, 3:4})</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"># set the number of iteration loops in the decomposition</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;cDecompose.set_iteration_loops({4: 3, 3: 3, 2: 3})</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"># setting the verbosity of the decomposition</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;cDecompose.set_verbose( <span class="keyword">True</span> )</div></div><!-- fragment --></div><p>By setting the number of identical blocks in the code snippet we order the code to use two identical successive blocks for the sub-disentanglement of the 4-qubit unitary:   <style>div.image img[src="layers_4qubit.png"]{width:600px;}</style>  </p><div class="image">
<img src="layers_4qubit.png" alt="layers_4qubit.png"/>
<div class="caption">
Two identical successive block in the sub-decomposition of the 4th qubit</div></div>
<p>and do not use repeated successive blocks in the decomposition of the 3-qubit submatrix:   <style>div.image img[src="layers_3qubit.png"]{width:500px;}</style>  </p><div class="image">
<img src="layers_3qubit.png" alt="layers_3qubit.png"/>
<div class="caption">
No repeated successive blocks in the sub-decomposition of the 3rd qubit</div></div>
<p>The idea behind setting two identical successive block is very straightforward. In this case the successive <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates might cancel each other resulting in possible simplification of the gate structure in the end of the decomposition process. Notice, that setting more the three identical blocks has no sense, since all two-qubit unitaries can be decomposed with at most three <a class="el" href="class_c_n_o_t.html" title="A class representing a CNOT operation. ">CNOT</a> gates.</p>
<p>In the second command of the code snippet above we set the maximal number of operation blocks allowed in the n-qubit sub-decomposition problem. The demonstrated choices are very much specific for the given problem. In case of general random unitaries, when the unitary is spanned by four qubits, than 60 operation blocks (layers) are needed to solve the sub-disentanglement problem, while for the sub-decomposition of a unitary spanned by three qubits are necessary at most 20 operation blocks. (These maximal parameters are in-built in the code, it is not necessary to provide them in the code.)</p>
<p>The third command in the above code snippet is about the setting of the number of iterations in each optimization step used during the sub-decomposition of the nth qubit. By default, the number of iteration loops are set to one, however in case of specific unitaries, such as the matrix of the 4th problem of the IBM challenge, the increase of the number of iteration loops is advised to avoid unwanted convergence to local minima. (On the other hand, the increase of the iteration loops might increase the running time.) We notice, that the best choice of the above parameters varies from problem to problem. One should give a try to multiple set of parameters to find the best decomposition of the unitary.</p>
<p>In the last command of the code snippet above one can set the verbosity of the decomposition to on/off by the value True/False. After setting the parameters of the decomposition we can start the optimization process by the command:</p>
<div class="snippet"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># starting the decomposition</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cDecompose.start_decomposition()</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"># list the decomposing operations</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;cDecompose.list_operations()</div></div><!-- fragment --></div><p>The second command in the above code snippet prints the list of decomposing operations on the standard output. Finally, we can export a Qiskit compatible quantum circuit via the QGD Python interface and calculate the final error of the decomposition by the following code snippet:</p>
<div class="snippet"> <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;print(<span class="stringliteral">&#39; &#39;</span>)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;print(<span class="stringliteral">&#39;Constructing quantum circuit:&#39;</span>)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;print(<span class="stringliteral">&#39; &#39;</span>)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">## Qiskit quantum circuit</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;quantum_circuit = cDecompose.get_quantum_circuit()</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;print(quantum_circuit)</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">from</span> qiskit <span class="keyword">import</span> execute</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">from</span> qiskit <span class="keyword">import</span> Aer</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> LA</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    </div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"># test the decomposition of the matrix</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">## Qiskit backend for simulator</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;backend = Aer.get_backend(<span class="stringliteral">&#39;unitary_simulator&#39;</span>)</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    </div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">## job execution and getting the result as an object</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;job = execute(quantum_circuit, backend)</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">## the result of the Qiskit job</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;result = job.result()</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    </div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">## the unitary matrix from the result object</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;decomposed_matrix = result.get_unitary(quantum_circuit)</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    </div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">## the Umtx*Umtx&#39; matrix</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;product_matrix = np.dot(Umtx, decomposed_matrix.conj().T)</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">## the error of the decomposition</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;decomposition_error =  LA.norm(product_matrix - np.identity(16)*product_matrix[0,0], 2)</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;print(<span class="stringliteral">&#39;The error of the decomposition is &#39;</span> + str(decomposition_error))</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div></div><!-- fragment --></div><p>The documentation of Qiskit, which is needed to fully understand the above code snippet, can be found <a href="https://qiskit.org/documentation/">here</a>. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 17 2020 17:48:23 for Quantum Gate Decomposer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
